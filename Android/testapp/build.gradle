apply plugin: 'com.android.application'

def autoDetectedCompileSdkVersion = fetchTargetSdkVersion(29)
def autoDectectedBuildToolsVersion = latestBuildToolsAvailable("29.0.2")

// Add a new entry to local.properties:
// prebuilt_external_libs.dir=/Users/ewing/Source/Blurrr/Release/BlurrrSDKApple/Libraries/SDK/Android/C
// Because Android's CMake has crippled FIND_* for external libraries, we need to work around it.
// So the solution is to require users (you) to put all the prebuilt libraries (i.e. .so's and include files) in a common root directory.
// This should contain a directory with a layout like the old Android NDK "module" system, which contains include/ and libs/<arch>/lib*.so
// So for example, the directory layout should look like should look like:
// <root> // this is your prebuilt_external_libs.dir
//    openal-soft/
//        include/
//            AL/
//                al.h
//        libs/
//            arm64-v8a/
//                libopenal.so
//            armeabi-v7a/
//                libopenal.so
//            x86/
//                libopenal.so
//            x86_64/
//                libopenal.so
//    mpg123/
//        include/
//            mpg123.h
//        libs/
//            arm64-v8a/
//                libmpg123.so
//            armeabi-v7a/
//                libmpg123.so
//            x86/
//                libmpg123.so
//            x86_64/
//                libmpg123.so
//    ogg/
//        include/
//            ogg/
//                ogg.h
//        libs/
//            arm64-v8a/
//                libogg.so
//            armeabi-v7a/
//                libogg.so
//            x86/
//                libogg.so
//            x86_64/
//                libogg.so
//    vorbis/
//        include/
//            vorbis/
//                vorbisfile.h
//                codec.h
//        libs/
//            arm64-v8a/
//                libvorbis.so
//                libvorbisfile.so
//            armeabi-v7a/
//                libvorbis.so
//                libvorbisfile.so
//            x86/
//                libvorbis.so
//                libvorbisfile.so
//            x86_64/
//                libvorbis.so
//                libvorbisfile.so
//
// This path will be passed to CMake as -DPREBUILT_LIBRARY_PATH because the Android cross-compile chain disables the FIND_ system with CMAKE_PREFIX_PATH and friends.
// This custom flag works in conjunction with our InitialCacheAndroid.cmake file which imperfectly mimics the FIND_ behavior by directly setting the values.
// You must always supply openal-soft.
// But mpg123, ogg, vorbis are only needed if you build ALmixer so the option to use them as external libraries.
Properties local_properties = new Properties()
local_properties.load(project.rootProject.file('local.properties').newDataInputStream())
def prebuilt_library_path = local_properties.getProperty('prebuilt_external_libs.dir')

android {
	compileSdkVersion autoDetectedCompileSdkVersion
	buildToolsVersion autoDectectedBuildToolsVersion
	defaultConfig {
		applicationId "net.playcontrol.luasocket.testapp"
		minSdkVersion 22
		targetSdkVersion autoDetectedCompileSdkVersion
		versionCode 1
		versionName "1.0"
//		testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
		externalNativeBuild {
			cmake {
				// The -C InitialCacheAndroid.cmake is our workaround for Android CMake's crippled FIND_* functions.
				// The InitialCacheAndroid.cmake will directly set the paths in CMake for the external libraries
				// rooted by the value you set in your local.properties for prebuilt_external_libs.dir=
				// This gets passed to CMake as the variable PREBUILT_LIBRARY_PATH (via the -D flag).
				// Then the code in InitialCacheAndroid.cmake sets all the variables.
				// If you want to enable/disable building ALmixer with external dependencies to libmpg123, ogg, vorbis (and .wav)
				// modify the SET (options) in InitialCacheAndroid.cmake.
				arguments "-DALMIXER_ANDROID_BUILD_TEST_LIBRARY=1",
					"-DBUILD_SHARED_LIBS=1",
					"-DPREBUILT_LIBRARY_PATH:FILEPATH=" + prebuilt_library_path,
					"-C../InitialCacheAndroid.cmake",
					"-DCMAKE_VERBOSE_MAKEFILE=1"
					cFlags ""
					cppFlags ""
			}
		}
		ndk {
			// Specifies the ABI configurations of your native
			// libraries Gradle should build and package with your APK.
			abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'
//			abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86_64'
//			abiFilters 'arm64-v8a', 'x86_64'
//			abiFilters 'armeabi-v7a', 'x86'
//		abiFilters 'armeabi-v7a'
//			abiFilters 'x86'
//			abiFilters 'arm64-v8a'
		}
	}
	buildTypes {
		release {
			minifyEnabled false
			proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
		}
	}
	externalNativeBuild {
		cmake {
		//	path "CMakeLists.txt"
			path "../../CMakeLists.txt"

		}
	}

	sourceSets {
		main {
			// Redirect the assets directory to use the sound files in ALmixer's EXAMPLES/resources directory
			assets.srcDirs = ['../../EXAMPLES/Resources']
			// This is used to force gradle to copy our external .so files into the .apk.
			// openal-soft is always needed.
			// But the rest are only needed if you build ALmixer using 3rd party mpg123, ogg, vorbis.
			jniLibs.srcDirs = [
				prebuilt_library_path + '/mpg123/libs',
				prebuilt_library_path + '/ogg/libs',
				prebuilt_library_path + '/vorbis/libs',
				prebuilt_library_path + '/openal-soft/libs'
			]
		}
	}

}

dependencies {
	implementation fileTree(dir: 'libs', include: ['*.jar'])
//	androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
//		exclude group: 'com.android.support', module: 'support-annotations'
//	})
	implementation 'com.android.support:appcompat-v7:28.0.0'
	implementation 'com.android.support.constraint:constraint-layout:1.1.3'

	implementation(project(":luasocket")) {
		// This didn't seem to do anything for me. (I was hitting a conflict when including the files myself.)
//		exclude module: 'IInAppBillingService'
		}

//	testImplementation 'junit:junit:4.12'

}



String fetchSdkRoot()
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def sdk_dir = properties.getProperty('sdk.dir')
		sdk_dir
	}
	else
	{
		println "Failed to find local.properties"
		'/Applications/Android Studio.app/sdk'
	}
}



String fetchNdkRoot()
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def ndk_dir = properties.getProperty('ndk.dir')
		ndk_dir
	}
	else
	{
		println "Failed to find local.properties"
		'/Applications/Android Studio.app/sdk'
	}
}

import java.util.regex.*
int fetchTargetSdkVersion(int default_value)
{
	/*
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def version = properties.getProperty('targetSdkVersion')
		version.toInteger()
	}
	else
	{
		println "Failed to find local.properties"
		default_value
	}
	*/
	def platform_dir = new File(fetchSdkRoot(), "platforms")
	// We should get directories like "android-14", "android-21", "android-25"
	// extract the number from "android-25" and convert to Integer

	def target_version_number_list = []

	def final_result = default_value
	def matcher_pattern = /android-(\d+)/

	platform_dir.list().each()
			{
				def find_result = (it =~ /$matcher_pattern/)
				/*
		m[0] is the first match object.
		m[0][0] is everything that matched in this match.
		m[0][1] is the first capture in this match.
		m[0][2] is the second capture in this match.
		 */
				if(find_result.size() > 0)
				{
					//	target_version_number_list.list().sort { a, b -> b <=> a }
					def found_version = find_result[0][1].toInteger()

//			println "got array match: " + found_version
					target_version_number_list.push(found_version);
				}
				else
				{
					println "Warning: Platform directory match did not find anything. Did Android break their file convention?"
				}
			}

	if(target_version_number_list.size() > 0)
	{
		target_version_number_list.sort { a, b -> b <=> a }
		final_result = target_version_number_list[0]
		println "Using latest found SDK for target SDK version: " + final_result
	}
	else
	{
		println "Warning: Could not auto-detect target sdk. Platform directory match did not find anything. Did Android break their file convention? Falling back to default value of: " + default_value

	}

//	println "target sdk version is: " + final_result

	final_result



}


int fetchMinSdkVersion(int default_value)
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def version = properties.getProperty('minSdkVersion')
		version.toInteger()
	}
	else
	{
		println "Failed to find local.properties"
		default_value
	}
}




String[] buildToolsAvailable() {
	def buildToolsDir = new File(fetchSdkRoot(), "build-tools")
	buildToolsDir.list().sort { a, b -> b <=> a }
}

// http://www.egeek.me/2013/12/07/gradle-auto-detect-android-sdk-and-build-tools-versions/
String latestBuildToolsAvailable(String defaultBuildTools) {
	try {
		def buildToolsVersions = buildToolsAvailable()
		def latestBuildTools = buildToolsVersions[0]
		if (latestBuildTools != null) {
			// Damn it. Android Studio contains an SDK with an inconsistent directory name.
			// The regular SDK has directories listed by tool number.
			// Studio lists e.g. Android-4.4.2.
			// As a workaround, both have a source.properties with the field:
			// Pkg.Revision=19.1

			def source_prop_dir = fetchSdkRoot() + '/build-tools/' + latestBuildTools
			def source_properties = new File(source_prop_dir, "source.properties")
			if(source_properties.exists())
			{
				Properties properties = new Properties()
				source_properties.withInputStream
						{
							instr -> properties.load(instr)
						}
				def version = properties.getProperty('Pkg.Revision')
				println "Using latest found build tools: " + version + " located in " + source_prop_dir
				version
			}
			else
			{
				println "Failed to find source.properties"
				defaultBuildTools
			}
		} else {
			println "No installed build tools found. Using default build tools " +
					defaultBuildTools
			defaultBuildTools
		}
	} catch (any) {
		println "Exception while determining latest build tools. Using default build tools " +
				defaultBuildTools
//        StackTraceUtils.sanitize(any).printStackTrace()
		defaultBuildTools
	}
}
