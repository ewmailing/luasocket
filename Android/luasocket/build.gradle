apply plugin: 'com.android.library'

def autoDetectedCompileSdkVersion = fetchTargetSdkVersion(29)
def autoDectectedBuildToolsVersion = latestBuildToolsAvailable("29.0.2")


// Add a new entry to local.properties:
// prebuilt_external_libs.dir=/Users/ewing/Source/Blurrr/Release/BlurrrSDKApple/Libraries/SDK/Android/C
// Because Android's CMake has crippled FIND_* for external libraries, we need to work around it.
// So the solution is to require users (you) to put all the prebuilt libraries (i.e. .so's and include files) in a common root directory.
// This should contain a directory with a layout like the old Android NDK "module" system, which contains include/ and libs/<arch>/lib*.so
// So for example, the directory layout should look like should look like:
// <root> // this is your prebuilt_external_libs.dir
//    openal-soft/
//        include/
//            AL/
//                al.h
//        libs/
//            arm64-v8a/
//                libopenal.so
//            armeabi-v7a/
//                libopenal.so
//            x86/
//                libopenal.so
//            x86_64/
//                libopenal.so
//    mpg123/
//        include/
//            mpg123.h
//        libs/
//            arm64-v8a/
//                libmpg123.so
//            armeabi-v7a/
//                libmpg123.so
//            x86/
//                libmpg123.so
//            x86_64/
//                libmpg123.so
//    ogg/
//        include/
//            ogg/
//                ogg.h
//        libs/
//            arm64-v8a/
//                libogg.so
//            armeabi-v7a/
//                libogg.so
//            x86/
//                libogg.so
//            x86_64/
//                libogg.so
//    vorbis/
//        include/
//            vorbis/
//                vorbisfile.h
//                codec.h
//        libs/
//            arm64-v8a/
//                libvorbis.so
//                libvorbisfile.so
//            armeabi-v7a/
//                libvorbis.so
//                libvorbisfile.so
//            x86/
//                libvorbis.so
//                libvorbisfile.so
//            x86_64/
//                libvorbis.so
//                libvorbisfile.so
//
// This path will be passed to CMake as -DPREBUILT_LIBRARY_PATH because the Android cross-compile chain disables the FIND_ system with CMAKE_PREFIX_PATH and friends.
// This custom flag works in conjunction with our InitialCacheAndroid.cmake file which imperfectly mimics the FIND_ behavior by directly setting the values.
// You must always supply openal-soft.
// But mpg123, ogg, vorbis are only needed if you build ALmixer so the option to use them as external libraries.
Properties local_properties = new Properties()
local_properties.load(project.rootProject.file('local.properties').newDataInputStream())
def prebuilt_library_path = local_properties.getProperty('prebuilt_external_libs.dir')

android {
	compileSdkVersion autoDetectedCompileSdkVersion
	buildToolsVersion autoDectectedBuildToolsVersion

	defaultConfig {
		minSdkVersion 22
		targetSdkVersion autoDetectedCompileSdkVersion
		versionCode 1
		versionName "1.0"

//		testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
		externalNativeBuild {
			cmake {
				cFlags ""
				cppFlags ""
				// The -C InitialCacheAndroid.cmake is our workaround for Android CMake's crippled FIND_* functions.
				// The InitialCacheAndroid.cmake will directly set the paths in CMake for the external libraries
				// rooted by the value you set in your local.properties for prebuilt_external_libs.dir=
				// This gets passed to CMake as the variable PREBUILT_LIBRARY_PATH (via the -D flag).
				// Then the code in InitialCacheAndroid.cmake sets all the variables.
				// If you want to enable/disable building ALmixer with external dependencies to libmpg123, ogg, vorbis (and .wav)
				// modify the SET (options) in InitialCacheAndroid.cmake.
				arguments "-DBUILD_SHARED_LIBS=1",
					"-DPREBUILT_LIBRARY_PATH:FILEPATH=" + prebuilt_library_path,
					"-C../InitialCacheAndroid.cmake",
					"-DCMAKE_VERBOSE_MAKEFILE=1"
			}
		}

		ndk {
			// Specifies the ABI configurations of your native
			// libraries Gradle should build and package with your APK.
			abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'
//			abiFilters 'arm64-v8a', 'x86_64'
//			abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86_64'
//			abiFilters 'armeabi-v7a', 'x86'
//			abiFilters 'armeabi-v7a'
//			abiFilters 'x86'
//			abiFilters 'arm64-v8a'
		}

		// pack up proguard rules
		consumerProguardFiles 'proguard-rules.pro'

	}
	buildTypes {
		release {
			minifyEnabled false
			// changed to consumerProguardFiles
//			proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
		}
	}

	externalNativeBuild {
		cmake {
			path "../../CMakeLists.txt"
		}
	}

/*
	aidlPackageWhiteList "com/android/vending/billing/IInAppBillingService.aidl"
	aidlPackageWhiteList "com/nokia/payment/iap/aidl/INokiaIAPService.aidl"
	aidlPackageWhiteList "com/sec/android/iap/IAPConnector.aidl"
	aidlPackageWhiteList "com/sec/android/iap/IAPServiceCallback.aidl"
	aidlPackageWhiteList "com/skubit/android/billing/IBillingService.aidl"
	aidlPackageWhiteList "org/onepf/oms/IOpenAppstore.aidl"
	aidlPackageWhiteList "org/onepf/oms/IOpenInAppBillingService.aidl"
*/

}


allprojects {
	repositories {
		maven { url 'https://raw.githubusercontent.com/onepf/OPF-mvn-repo/master/' }
		jcenter()
	}
}


dependencies {
	implementation fileTree(dir: 'libs', include: ['*.jar'])
//	androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
//		exclude group: 'com.android.support', module: 'support-annotations'
//	})
	implementation 'com.android.support:appcompat-v7:28.0.0'
//	testImplementation 'junit:junit:4.12'

	// need OpenIAB
//	compile ('org.onepf:openiab:0.9.8.6') {
		// This didn't seem to do anything for me. (I was hitting a conflict when including the files myself.)
//		exclude module: 'IInAppBillingService'
//	}

}

// Gradle is not putting the OpenIAB .jar in the .aar and there doesn't seem to be an official way to do this.
// https://gist.github.com/qrtt1/25a44fa29e46a5ec7f5b#file-aar-deps-gradle
// Bug: This must be built twice because the first pass misses the jars for some reason.
// Update: Gradle might copy if using a local .jar instead of one downloaded/compiled.
//project.afterEvaluate {
//	def isAndroidLibraryProject = project.plugins.hasPlugin('com.android.library')
//	if(isAndroidLibraryProject) {
//		task copyReleaseDeps(type:Copy) {
//			from configurations.compile {
//				include '**/openiab*.jar'
//			}
//			into "./build/intermediates/bundles/release/libs/"
//		}
//		assembleRelease.dependsOn copyReleaseDeps
//
//		task copyDebugDeps(type:Copy) {
//			from configurations.compile {
//				include '**/openiab*.jar'
//			}
//			into "./build/intermediates/bundles/debug/libs/"
//		}
//		assembleDebug.dependsOn copyDebugDeps
//	}
//}
// I gave up on trying to bundle .jar in .aar so I manually copy it. But I am having a problem finding the jar and this code seems to know where it is. So I copy it to myjarstaging

//project.afterEvaluate {
//	def isAndroidLibraryProject = project.plugins.hasPlugin('com.android.library')
//	if(isAndroidLibraryProject) {
//		task copyReleaseDeps(type:Copy) {
//			from configurations.compile {
//				include '**/openiab*.jar'
//			}
//			into "./build/myjarstaging/release/"
//		}
//		assembleRelease.dependsOn copyReleaseDeps
//
//		task copyDebugDeps(type:Copy) {
//			from configurations.compile {
//				include '**/openiab*.jar'
//			}
//			into "./build/myjarstaging/debug/"
//		}
//		assembleDebug.dependsOn copyDebugDeps
//	}
//}


String fetchSdkRoot()
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def sdk_dir = properties.getProperty('sdk.dir')
		sdk_dir
	}
	else
	{
		println "Failed to find local.properties"
		'/Applications/Android Studio.app/sdk'
	}
}



String fetchNdkRoot()
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def ndk_dir = properties.getProperty('ndk.dir')
		ndk_dir
	}
	else
	{
		println "Failed to find local.properties"
		'/Applications/Android Studio.app/sdk'
	}
}

import java.util.regex.*
int fetchTargetSdkVersion(int default_value)
{
	/*
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def version = properties.getProperty('targetSdkVersion')
		version.toInteger()
	}
	else
	{
		println "Failed to find local.properties"
		default_value
	}
	*/
	def platform_dir = new File(fetchSdkRoot(), "platforms")
	// We should get directories like "android-14", "android-21", "android-25"
	// extract the number from "android-25" and convert to Integer

	def target_version_number_list = []

	def final_result = default_value
	def matcher_pattern = /android-(\d+)/

	platform_dir.list().each()
	{
		def find_result = (it =~ /$matcher_pattern/)
		/*
m[0] is the first match object.
m[0][0] is everything that matched in this match.
m[0][1] is the first capture in this match.
m[0][2] is the second capture in this match.
 */
		if(find_result.size() > 0)
		{
			//	target_version_number_list.list().sort { a, b -> b <=> a }
			def found_version = find_result[0][1].toInteger()

//			println "got array match: " + found_version
			target_version_number_list.push(found_version);
		}
		else
		{
			println "Warning: Platform directory match did not find anything. Did Android break their file convention?"
		}
	}

	if(target_version_number_list.size() > 0)
	{
		target_version_number_list.sort { a, b -> b <=> a }
		final_result = target_version_number_list[0]
		println "Using latest found SDK for target SDK version: " + final_result
	}
	else
	{
		println "Warning: Could not auto-detect target sdk. Platform directory match did not find anything. Did Android break their file convention? Falling back to default value of: " + default_value

	}

//	println "target sdk version is: " + final_result

	final_result



}


int fetchMinSdkVersion(int default_value)
{
	def root_dir = project.rootDir
	def local_properties = new File(root_dir, "local.properties")
	if(local_properties.exists())
	{
		Properties properties = new Properties()
		local_properties.withInputStream
				{
					instr -> properties.load(instr)
				}
		def version = properties.getProperty('minSdkVersion')
		version.toInteger()
	}
	else
	{
		println "Failed to find local.properties"
		default_value
	}
}




String[] buildToolsAvailable() {
	def buildToolsDir = new File(fetchSdkRoot(), "build-tools")
	buildToolsDir.list().sort { a, b -> b <=> a }
}

// http://www.egeek.me/2013/12/07/gradle-auto-detect-android-sdk-and-build-tools-versions/
String latestBuildToolsAvailable(String defaultBuildTools) {
	try {
		def buildToolsVersions = buildToolsAvailable()
		def latestBuildTools = buildToolsVersions[0]
		if (latestBuildTools != null) {
			// Damn it. Android Studio contains an SDK with an inconsistent directory name.
			// The regular SDK has directories listed by tool number.
			// Studio lists e.g. Android-4.4.2.
			// As a workaround, both have a source.properties with the field:
			// Pkg.Revision=19.1

			def source_prop_dir = fetchSdkRoot() + '/build-tools/' + latestBuildTools
			def source_properties = new File(source_prop_dir, "source.properties")
			if(source_properties.exists())
			{
				Properties properties = new Properties()
				source_properties.withInputStream
						{
							instr -> properties.load(instr)
						}
				def version = properties.getProperty('Pkg.Revision')
				println "Using latest found build tools: " + version + " located in " + source_prop_dir
				version
			}
			else
			{
				println "Failed to find source.properties"
				defaultBuildTools
			}
		} else {
			println "No installed build tools found. Using default build tools " +
					defaultBuildTools
			defaultBuildTools
		}
	} catch (any) {
		println "Exception while determining latest build tools. Using default build tools " +
				defaultBuildTools
//        StackTraceUtils.sanitize(any).printStackTrace()
		defaultBuildTools
	}
}
